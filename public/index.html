<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kalsu - Direct P2P Transfer</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://challenges.cloudflare.com">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://challenges.cloudflare.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@600&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-primary: #09090b;
      --bg-secondary: #18181b;
      --bg-tertiary: #27272a;
      --border-primary: #3f3f46;
      --border-secondary: #52525b;
      --text-primary: #fafafa;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --emerald-400: #34d399;
      --emerald-500: #10b981;
      --emerald-600: #059669;
      --teal-400: #2dd4bf;
      --teal-500: #14b8a6;
      --red-400: #f87171;
      --red-500: #ef4444;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background-image: 
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(16, 185, 129, 0.15), transparent),
        radial-gradient(ellipse 60% 40% at 50% 120%, rgba(20, 184, 166, 0.1), transparent);
    }

    .container {
      width: 100%;
      max-width: 480px;
    }

    /* Header */
    .header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .logo {
      font-size: 2.25rem;
      font-weight: 600;
      background: linear-gradient(135deg, var(--emerald-400), var(--teal-400));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.9375rem;
      margin-top: 0.375rem;
      font-weight: 500;
    }

    .subtitle-desc {
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-top: 0.5rem;
      font-weight: 400;
      max-width: 320px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.5;
    }

    /* Switcher */
    .switcher {
      display: flex;
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 12px;
      padding: 4px;
      margin-bottom: 1.5rem;
      position: relative;
    }

    .switcher-bg {
      position: absolute;
      top: 4px;
      left: 4px;
      width: calc(50% - 4px);
      height: calc(100% - 8px);
      background: linear-gradient(135deg, var(--emerald-500), var(--teal-500));
      border-radius: 8px;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 0;
    }

    .switcher-bg.receive {
      transform: translateX(100%);
    }

    .switcher-btn {
      flex: 1;
      padding: 0.75rem 1rem;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 8px;
      transition: color 0.2s;
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .switcher-btn.active {
      color: var(--bg-primary);
    }

    .switcher-btn:not(.active):hover {
      color: var(--text-primary);
    }

    /* Panel */
    .panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 16px;
      padding: 1.5rem;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .panel.hidden {
      display: none;
    }

    /* General hidden utility */
    .hidden {
      display: none !important;
    }

    /* Dropzone */
    .dropzone {
      border: 2px dashed var(--border-primary);
      border-radius: 12px;
      padding: 3rem 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }

    .dropzone::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--emerald-500), var(--teal-500));
      opacity: 0;
      transition: opacity 0.3s;
    }

    .dropzone:hover,
    .dropzone.dragover {
      border-color: var(--emerald-500);
    }

    .dropzone:hover::before,
    .dropzone.dragover::before {
      opacity: 0.05;
    }

    .dropzone.dragover {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { border-color: var(--emerald-500); }
      50% { border-color: var(--teal-400); }
    }

    .dropzone-icon {
      width: 48px;
      height: 48px;
      margin: 0 auto 1rem;
      color: var(--text-muted);
      transition: color 0.2s;
    }

    .dropzone:hover .dropzone-icon {
      color: var(--emerald-400);
    }

    .dropzone-text {
      color: var(--text-secondary);
      font-size: 0.9375rem;
    }

    .dropzone-text strong {
      color: var(--emerald-400);
      font-weight: 600;
    }

    .dropzone-hint {
      color: var(--text-muted);
      font-size: 0.8125rem;
      margin-top: 0.5rem;
    }

    .file-input {
      display: none;
    }

    /* File Card */
    .file-card {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 10px;
      margin-bottom: 1.5rem;
    }

    .file-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--emerald-500), var(--teal-500));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--bg-primary);
      flex-shrink: 0;
    }

    .file-info {
      flex: 1;
      min-width: 0;
    }

    .file-name {
      font-weight: 600;
      font-size: 0.9375rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-size {
      color: var(--text-muted);
      font-size: 0.8125rem;
      margin-top: 2px;
    }

    .file-remove {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .file-remove:hover {
      background: rgba(239, 68, 68, 0.1);
      color: var(--red-400);
    }

    /* Large file warning */
    .large-file-warning {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-radius: 8px;
      color: #fbbf24;
      font-size: 0.8125rem;
      margin-bottom: 1rem;
    }

    /* Passphrase */
    .passphrase-section {
      text-align: center;
    }

    .passphrase-label {
      color: var(--text-muted);
      font-size: 0.8125rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.75rem;
    }

    .passphrase-code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.75rem;
      font-weight: 600;
      color: var(--emerald-400);
      background: var(--bg-tertiary);
      padding: 1rem 1.5rem;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
    }

    .passphrase-code:hover {
      border-color: var(--emerald-500);
      background: rgba(16, 185, 129, 0.1);
    }

    .passphrase-code svg {
      width: 20px;
      height: 20px;
      color: var(--text-muted);
    }

    .passphrase-hint {
      color: var(--text-muted);
      font-size: 0.8125rem;
      margin-top: 0.75rem;
    }

    .passphrase-copied {
      color: var(--emerald-400);
    }

    /* Waiting state */
    .waiting-state {
      text-align: center;
      padding: 1rem 0;
    }

    .waiting-spinner {
      width: 24px;
      height: 24px;
      border: 2px solid var(--border-primary);
      border-top-color: var(--emerald-400);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .waiting-text {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .code-expiry {
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-top: 0.5rem;
    }

    .code-expiry span {
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    /* Receiver Panel */
    .input-group {
      display: flex;
      gap: 0.75rem;
    }

    .passphrase-input {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-primary);
      border-radius: 10px;
      padding: 0.875rem 1rem;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .passphrase-input::placeholder {
      color: var(--text-muted);
    }

    .passphrase-input:focus {
      border-color: var(--emerald-500);
    }

    .get-btn {
      background: linear-gradient(135deg, var(--emerald-500), var(--teal-500));
      border: none;
      border-radius: 10px;
      padding: 0.875rem 1.5rem;
      color: var(--bg-primary);
      font-family: inherit;
      font-size: 0.9375rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .get-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .get-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Transfer Overlay */
    .transfer-overlay {
      position: fixed;
      inset: 0;
      background: rgba(9, 9, 11, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      animation: fadeIn 0.3s ease;
    }


    .transfer-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 16px;
      padding: 2rem;
      width: 100%;
      max-width: 400px;
      text-align: center;
    }

    .transfer-status {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--emerald-400);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .transfer-filename {
      font-weight: 600;
      font-size: 1.125rem;
      margin-bottom: 1.5rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .progress-container {
      background: var(--bg-tertiary);
      border-radius: 8px;
      height: 8px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--emerald-500), var(--teal-400));
      border-radius: 8px;
      transition: width 0.3s ease;
      position: relative;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .transfer-stats {
      display: flex;
      justify-content: space-between;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .transfer-stat-value {
      font-weight: 600;
      color: var(--text-primary);
    }

    /* Complete state */
    .transfer-complete {
      padding: 1rem 0;
    }

    .transfer-complete-icon {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, var(--emerald-500), var(--teal-500));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 1rem;
      color: var(--bg-primary);
    }

    .transfer-complete-text {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .transfer-complete-hint {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .close-btn {
      margin-top: 1.5rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-primary);
      border-radius: 10px;
      padding: 0.75rem 2rem;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.9375rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .close-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--border-secondary);
    }

    /* Error state */
    .error-message {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 10px;
      padding: 1rem;
      color: var(--red-400);
      font-size: 0.875rem;
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }


    /* Footer */
    .footer {
      margin-top: 2rem;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .footer a {
      color: var(--text-secondary);
      text-decoration: none;
      transition: color 0.2s;
    }

    .footer a:hover {
      color: var(--emerald-400);
    }

    /* Prevent button text wrap */
    .get-btn {
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* Mobile responsive */
    @media (max-width: 480px) {
      body {
        padding: 1rem;
      }

      .logo {
        font-size: 1.75rem;
      }

      .subtitle {
        font-size: 0.8125rem;
      }

      .subtitle-desc {
        font-size: 0.6875rem;
        max-width: 280px;
      }

      .header {
        margin-bottom: 1.5rem;
      }

      .switcher {
        margin-bottom: 1rem;
      }

      .panel {
        padding: 1rem;
      }

      .dropzone {
        padding: 2rem 1rem;
      }

      .passphrase-code {
        font-size: 1.25rem;
        padding: 0.75rem 1rem;
        word-break: break-all;
        flex-wrap: wrap;
        justify-content: center;
      }

      .input-group {
        flex-direction: column;
      }

      .get-btn {
        width: 100%;
        justify-content: center;
        padding: 1rem;
      }

      .transfer-card {
        margin: 1rem;
        padding: 1.5rem;
      }

      .transfer-filename {
        font-size: 1rem;
      }

      .file-card {
        padding: 0.75rem;
        gap: 0.75rem;
      }

      .file-name {
        font-size: 0.875rem;
      }

      .footer {
        margin-top: 1.5rem;
      }
    }

    /* Phosphor icon sizing */
    .switcher-btn i { font-size: 18px; line-height: 1; }
    .dropzone-icon { font-size: 48px; color: var(--text-muted); }
    .file-icon i { font-size: 20px; }
    .file-remove i { font-size: 18px; }
    .large-file-warning i { font-size: 16px; }
    .passphrase-code i { font-size: 18px; color: var(--text-muted); }
    .error-message i { font-size: 18px; }
    .get-btn i { font-size: 18px; }
    .transfer-complete-icon i { font-size: 32px; }

    /* Hint text */
    .hint-text {
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-top: 1.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
    }

    .hint-text i {
      font-size: 14px;
      color: var(--emerald-400);
      opacity: 0.7;
    }

    .hint-text--left {
      justify-content: flex-start;
    }

    /* Security badge style hint */
    .security-hint {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      color: var(--text-muted);
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      padding: 0.375rem 0.625rem;
      background: rgba(16, 185, 129, 0.08);
      border: 1px solid rgba(16, 185, 129, 0.15);
      border-radius: 100px;
      margin-top: 0.75rem;
    }

    .security-hint i {
      font-size: 12px;
      color: var(--emerald-400);
    }

    /* Button loading state */
    .btn-loading {
      position: relative;
      pointer-events: none;
    }

    .btn-loading .btn-text {
      opacity: 0.7;
    }

    @keyframes subtle-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    .btn-loading {
      animation: subtle-pulse 1.5s ease-in-out infinite;
    }

    /* Footer enhanced */
    .footer-security {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .footer-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      color: var(--text-muted);
      font-size: 0.6875rem;
    }

    .footer-badge i {
      font-size: 12px;
      color: var(--emerald-400);
      opacity: 0.6;
    }

    .footer-divider {
      color: var(--border-primary);
      font-size: 0.5rem;
    }

    .footer-links {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .footer-links a {
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.6875rem;
      transition: color 0.2s;
    }

    .footer-links a:hover {
      color: var(--emerald-400);
    }

    @media (max-width: 480px) {
      .footer-security {
        gap: 0.375rem;
      }

      .footer-badge {
        font-size: 0.625rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1 class="logo">KALSU</h1>
      <p class="subtitle">Send files directly between browsers</p>
      <p class="subtitle-desc">Powered by WebRTC — the same technology behind Google Meet. No servers store your files.</p>
    </header>

    <!-- Mode Switcher -->
    <div class="switcher">
      <div class="switcher-bg" id="switcherBg"></div>
      <button class="switcher-btn active" id="sendBtn" data-mode="send">
        <i class="ph ph-upload-simple"></i>
        Send
      </button>
      <button class="switcher-btn" id="receiveBtn" data-mode="receive">
        <i class="ph ph-download-simple"></i>
        Receive
      </button>
    </div>

    <!-- Send Panel -->
    <div class="panel" id="sendPanel">
      <!-- Dropzone (no file selected) -->
      <div id="dropzoneContainer">
        <div class="dropzone" id="dropzone">
          <i class="ph ph-cloud-arrow-up dropzone-icon"></i>
          <p class="dropzone-text"><strong>Click to upload</strong> or drag and drop</p>
          <p class="dropzone-hint">Any file type</p>
        </div>
        <p class="hint-text"><i class="ph ph-shield-check"></i> Your file stays on your device until someone connects</p>
        <input type="file" class="file-input" id="fileInput">
      </div>

      <!-- File selected state -->
      <div id="fileSelectedContainer" class="hidden">
        <div class="file-card">
          <div class="file-icon">
            <i class="ph ph-file"></i>
          </div>
          <div class="file-info">
            <div class="file-name" id="fileName">document.pdf</div>
            <div class="file-size" id="fileSize">2.4 MB</div>
          </div>
          <button class="file-remove" id="fileRemove">
            <i class="ph ph-x"></i>
          </button>
        </div>

        <div class="large-file-warning hidden" id="largeFileWarning">
          <i class="ph ph-warning-circle"></i>
          <span>Large files may take a while to transfer</span>
        </div>

        <div class="passphrase-section">
          <div class="passphrase-label">Your Secret Code</div>
          <div class="passphrase-code" id="passphraseCode">
            <span id="passphraseText">loading...</span>
            <i class="ph ph-copy-simple"></i>
          </div>
          <p class="passphrase-hint" id="passphraseHint">Click to copy</p>
        </div>

        <div class="waiting-state hidden" id="waitingState">
          <div class="waiting-spinner"></div>
          <p class="waiting-text">Waiting for receiver to connect...</p>
          <p class="code-expiry" id="codeExpiry">Code valid for <span id="codeExpiryTime">10:00</span></p>
          <div class="security-hint">
            <i class="ph ph-lock-simple"></i>
            Direct transfer · Nothing stored on servers
          </div>
        </div>

        <div class="error-message hidden" id="senderErrorMessage">
          <i class="ph ph-warning-circle"></i>
          <span id="senderErrorText">Connection failed. Please try again.</span>
        </div>
      </div>
    </div>

    <!-- Receive Panel -->
    <div class="panel hidden" id="receivePanel">
      <div class="input-group">
        <input type="text" class="passphrase-input" id="passphraseInput" placeholder="secret-code-from-sender" autocomplete="off" spellcheck="false">
        <button class="get-btn" id="getFileBtn">
          <i class="ph ph-download-simple" id="getFileBtnIcon"></i>
          <span class="btn-text" id="getFileBtnText">Get File</span>
        </button>
      </div>
      <p class="hint-text hint-text--left"><i class="ph ph-shield-check"></i> Files transfer directly to you, nothing is stored on servers</p>
      <div class="error-message hidden" id="errorMessage">
        <i class="ph ph-warning-circle"></i>
        <span id="errorText">Connection failed. Please check the code and try again.</span>
      </div>
    </div>

    <!-- Invisible Turnstile widget -->
    <div id="turnstile-container" style="display: none;"></div>

    <footer class="footer">
      <div class="footer-security">
        <span class="footer-badge"><i class="ph ph-lock-simple"></i> End-to-end encrypted</span>
        <span class="footer-divider">·</span>
        <span class="footer-badge"><i class="ph ph-arrows-left-right"></i> Peer-to-peer</span>
        <span class="footer-divider">·</span>
        <span class="footer-badge"><i class="ph ph-cloud-slash"></i> Nothing stored on servers</span>
      </div>
      <div class="footer-links">
        <a href="/privacy.html">Privacy</a>
        <span class="footer-divider">·</span>
        <a href="/terms.html">Terms</a>
        <span class="footer-divider">·</span>
        <a href="https://github.com/roopen219/kalsu" target="_blank" rel="noopener">GitHub</a>
      </div>
    </footer>
  </div>

  <!-- Transfer Overlay -->
  <div class="transfer-overlay hidden" id="transferOverlay">
    <div class="transfer-card">
      <!-- Progress state -->
      <div id="transferProgress">
        <div class="transfer-status" id="transferStatus">Sending</div>
        <div class="transfer-filename" id="transferFilename">document.pdf</div>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
        <div class="transfer-stats">
          <div>
            <span class="transfer-stat-value" id="transferPercent">0%</span>
          </div>
          <div>
            <span class="transfer-stat-value" id="transferSpeed">0 MB/s</span>
          </div>
          <div>
            <span class="transfer-stat-value" id="transferEta">--:--</span>
          </div>
        </div>
        <div class="security-hint" style="margin-top: 1.25rem;">
          <i class="ph ph-lock-simple"></i>
          Secure transfer · Nothing stored
        </div>
      </div>

      <!-- Complete state -->
      <div class="transfer-complete hidden" id="transferComplete">
        <div class="transfer-complete-icon">
          <i class="ph ph-check"></i>
        </div>
        <div class="transfer-complete-text">Transfer Complete!</div>
        <div class="transfer-complete-hint" id="transferCompleteHint">File sent successfully</div>
        <div class="security-hint" id="transferSecurityHint">
          <i class="ph ph-shield-check"></i>
          <span id="transferSecurityText">No copy was stored on any server</span>
        </div>
        <button class="close-btn" id="closeTransferBtn">Done</button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <script src="https://unpkg.com/@phosphor-icons/web@2.1.1"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"></script>

  <script>
    // State
    let currentMode = 'send';
    let selectedFile = null;
    let passphrase = null;
    let ws = null;
    let peer = null;
    let isTransferring = false;
    let codeExpiryInterval = null;
    let codeExpirySeconds = 600; // 10 minutes

    // Constants
    const CHUNK_SIZE = 64 * 1024; // 64KB
    // Magic prefix: null byte + KALSU + null byte (very unlikely in real files)
    const CTRL_PREFIX = '\x00KALSU\x00';

    // Turnstile state (site key fetched from server)
    let turnstileSiteKey = null;
    let turnstileToken = null;
    let turnstileWidgetId = null;
    let turnstileReady = false;

    // DOM Elements
    const switcherBg = document.getElementById('switcherBg');
    const sendBtn = document.getElementById('sendBtn');
    const receiveBtn = document.getElementById('receiveBtn');
    const sendPanel = document.getElementById('sendPanel');
    const receivePanel = document.getElementById('receivePanel');
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const dropzoneContainer = document.getElementById('dropzoneContainer');
    const fileSelectedContainer = document.getElementById('fileSelectedContainer');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const fileRemove = document.getElementById('fileRemove');
    const largeFileWarning = document.getElementById('largeFileWarning');
    const passphraseCode = document.getElementById('passphraseCode');
    const passphraseText = document.getElementById('passphraseText');
    const passphraseHint = document.getElementById('passphraseHint');
    const waitingState = document.getElementById('waitingState');
    const codeExpiryTime = document.getElementById('codeExpiryTime');
    const passphraseInput = document.getElementById('passphraseInput');
    const getFileBtn = document.getElementById('getFileBtn');
    const errorMessage = document.getElementById('errorMessage');
    const errorText = document.getElementById('errorText');
    const senderErrorMessage = document.getElementById('senderErrorMessage');
    const senderErrorText = document.getElementById('senderErrorText');
    const transferOverlay = document.getElementById('transferOverlay');
    const transferProgress = document.getElementById('transferProgress');
    const transferComplete = document.getElementById('transferComplete');
    const transferStatus = document.getElementById('transferStatus');
    const transferFilename = document.getElementById('transferFilename');
    const progressBar = document.getElementById('progressBar');
    const transferPercent = document.getElementById('transferPercent');
    const transferSpeed = document.getElementById('transferSpeed');
    const transferEta = document.getElementById('transferEta');
    const transferCompleteHint = document.getElementById('transferCompleteHint');
    const transferSecurityText = document.getElementById('transferSecurityText');
    const closeTransferBtn = document.getElementById('closeTransferBtn');
    const getFileBtnText = document.getElementById('getFileBtnText');
    const getFileBtnIcon = document.getElementById('getFileBtnIcon');

    // Utility functions
    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatTime(seconds) {
      if (!isFinite(seconds) || seconds < 0) return '--:--';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    async function fetchPassphrase() {
      // Get Turnstile token first
      let token;
      try {
        token = await getTurnstileToken();
      } catch (e) {
        throw new Error('Security verification failed. Please refresh and try again.');
      }
      
      const response = await fetch('/api/passphrase', {
        headers: {
          'X-Turnstile-Token': token
        }
      });
      
      if (response.status === 429) {
        const data = await response.json();
        throw new Error(data.error || 'Rate limit exceeded. Please wait a moment.');
      }
      
      if (response.status === 403) {
        throw new Error('Security verification failed. Please refresh and try again.');
      }
      
      if (!response.ok) {
        throw new Error('Failed to generate code. Please try again.');
      }
      
      const data = await response.json();
      return data.passphrase;
    }

    function getWebSocketUrl(code, token) {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      return `${protocol}//${window.location.host}/ws/${code}?token=${encodeURIComponent(token)}`;
    }

    // Turnstile initialization
    async function initTurnstile() {
      // Fetch site key from server
      if (!turnstileSiteKey) {
        try {
          const response = await fetch('/api/config');
          const config = await response.json();
          turnstileSiteKey = config.turnstileSiteKey;
        } catch (e) {
          console.error('Failed to fetch config:', e);
          setTimeout(initTurnstile, 1000);
          return;
        }
      }

      // Wait for Turnstile script to load
      if (typeof turnstile === 'undefined') {
        setTimeout(initTurnstile, 100);
        return;
      }
      
      turnstileWidgetId = turnstile.render('#turnstile-container', {
        sitekey: turnstileSiteKey,
        callback: (token) => {
          turnstileToken = token;
        },
        'expired-callback': () => {
          turnstileToken = null;
          // Auto-refresh on expiry
          turnstile.reset(turnstileWidgetId);
        },
        'error-callback': () => {
          turnstileToken = null;
        }
      });
      
      turnstileReady = true;
    }

    // Get a fresh Turnstile token (with retry)
    async function getTurnstileToken() {
      // Wait for Turnstile to be ready first
      if (!turnstileReady) {
        await new Promise((resolve, reject) => {
          let attempts = 0;
          const checkReady = () => {
            if (turnstileReady) {
              resolve();
            } else if (attempts >= 50) {
              reject(new Error('Turnstile initialization timed out'));
            } else {
              attempts++;
              setTimeout(checkReady, 100);
            }
          };
          checkReady();
        });
      }

      // If we have a token, return it
      if (turnstileToken) {
        const token = turnstileToken;
        turnstileToken = null; // Clear to prevent reuse
        // Reset widget for next use
        if (turnstileWidgetId !== null) {
          turnstile.reset(turnstileWidgetId);
        }
        return token;
      }
      
      // Wait for token with timeout
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 50; // 5 seconds max
        
        const checkToken = () => {
          if (turnstileToken) {
            const token = turnstileToken;
            turnstileToken = null; // Clear to prevent reuse
            if (turnstileWidgetId !== null) {
              turnstile.reset(turnstileWidgetId);
            }
            resolve(token);
          } else if (attempts >= maxAttempts) {
            reject(new Error('Turnstile verification timed out'));
          } else {
            attempts++;
            setTimeout(checkToken, 100);
          }
        };
        checkToken();
      });
    }

    // Initialize Turnstile when page loads
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initTurnstile);
    } else {
      initTurnstile();
    }

    // Mode switching
    function switchMode(mode) {
      if (currentMode === mode) return; // Already on this mode
      currentMode = mode;
      
      if (mode === 'send') {
        switcherBg.classList.remove('receive');
        sendBtn.classList.add('active');
        receiveBtn.classList.remove('active');
        sendPanel.classList.remove('hidden');
        receivePanel.classList.add('hidden');
        // Clear receiver-specific state only
        errorMessage.classList.add('hidden');
        passphraseInput.value = '';
        // Reset button state
        getFileBtn.disabled = false;
        getFileBtn.classList.remove('btn-loading');
        getFileBtnText.textContent = 'Get File';
        getFileBtnIcon.className = 'ph ph-download-simple';
      } else {
        switcherBg.classList.add('receive');
        receiveBtn.classList.add('active');
        sendBtn.classList.remove('active');
        receivePanel.classList.remove('hidden');
        sendPanel.classList.add('hidden');
        // Clear sender-specific error state only (keep file/passphrase/ws)
        senderErrorMessage.classList.add('hidden');
      }
    }

    function resetState() {
      if (ws) {
        ws.close();
        ws = null;
      }
      if (peer) {
        peer.destroy();
        peer = null;
      }
      
      // Stop code expiry timer
      stopCodeExpiryTimer();
      
      // Clean up transfer state
      if (writer) {
        try { writer.abort(); } catch (e) {}
        writer = null;
      }
      fileStream = null;
      incomingFileInfo = null;
      bytesTransferred = 0;
      transferStartTime = 0;
      writeQueue = Promise.resolve();
      
      selectedFile = null;
      passphrase = null;
      isTransferring = false;

      dropzoneContainer.classList.remove('hidden');
      fileSelectedContainer.classList.add('hidden');
      waitingState.classList.add('hidden');
      errorMessage.classList.add('hidden');
      senderErrorMessage.classList.add('hidden');
      largeFileWarning.classList.add('hidden');
      transferOverlay.classList.add('hidden');
      passphraseInput.value = '';
      fileInput.value = '';
      // Reset Get File button state
      getFileBtn.disabled = false;
      getFileBtn.classList.remove('btn-loading');
      getFileBtnText.textContent = 'Get File';
      getFileBtnIcon.className = 'ph ph-download-simple';
    }

    sendBtn.addEventListener('click', () => switchMode('send'));
    receiveBtn.addEventListener('click', () => switchMode('receive'));

    // File selection
    dropzone.addEventListener('click', () => fileInput.click());
    
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });

    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('dragover');
    });

    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        handleFileSelect(e.dataTransfer.files[0]);
      }
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFileSelect(e.target.files[0]);
      }
    });

    async function handleFileSelect(file) {
      selectedFile = file;
      fileName.textContent = file.name;
      fileSize.textContent = formatBytes(file.size);
      
      dropzoneContainer.classList.add('hidden');
      fileSelectedContainer.classList.remove('hidden');

      // Show warning for large files (>100MB)
      const LARGE_FILE_THRESHOLD = 100 * 1024 * 1024; // 100MB
      if (file.size > LARGE_FILE_THRESHOLD) {
        largeFileWarning.classList.remove('hidden');
      } else {
        largeFileWarning.classList.add('hidden');
      }

      // Show loading state while fetching passphrase
      passphraseText.textContent = 'generating...';
      passphraseHint.textContent = '';
      passphraseHint.classList.remove('passphrase-copied');
      passphraseHint.style.color = '';

      try {
        // Fetch passphrase from server
        passphrase = await fetchPassphrase();
        passphraseText.textContent = passphrase;
        passphraseHint.textContent = 'Click to copy';
        await connectAsSender();
      } catch (error) {
        console.error('Passphrase generation failed:', error);
        passphraseText.textContent = 'error';
        passphraseHint.textContent = error.message;
        passphraseHint.style.color = 'var(--red-400)';
        // Reset after delay to allow retry
        setTimeout(() => {
          resetState();
        }, 3000);
      }
    }

    fileRemove.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent any parent handlers
      resetState();
    });

    // Copy passphrase
    passphraseCode.addEventListener('click', async () => {
      if (!passphrase) return; // Guard against null passphrase
      try {
        await navigator.clipboard.writeText(passphrase);
        passphraseHint.textContent = 'Copied!';
        passphraseHint.classList.add('passphrase-copied');
        setTimeout(() => {
          passphraseHint.textContent = 'Click to copy';
          passphraseHint.classList.remove('passphrase-copied');
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });

    // Receiver
    // Helper to set button loading state
    function setButtonLoading(loading) {
      if (loading) {
        getFileBtn.disabled = true;
        getFileBtn.classList.add('btn-loading');
        getFileBtnText.textContent = 'Verifying...';
        getFileBtnIcon.className = 'ph ph-spinner';
      } else {
        getFileBtn.disabled = false;
        getFileBtn.classList.remove('btn-loading');
        getFileBtnText.textContent = 'Get File';
        getFileBtnIcon.className = 'ph ph-download-simple';
      }
    }

    getFileBtn.addEventListener('click', async () => {
      const code = passphraseInput.value.trim().toLowerCase();
      if (!code) return;
      
      errorMessage.classList.add('hidden');
      setButtonLoading(true);

      // Validate room exists before connecting
      try {
        // Get Turnstile token first
        let token;
        try {
          token = await getTurnstileToken();
        } catch (e) {
          setButtonLoading(false);
          showError('Security verification failed. Please refresh and try again.');
          return;
        }
        
        const response = await fetch(`/api/room/${encodeURIComponent(code)}`, {
          headers: {
            'X-Turnstile-Token': token
          }
        });
        
        if (response.status === 429) {
          showError('Too many attempts. Please wait a moment.');
          return;
        }
        
        if (response.status === 403) {
          showError('Security verification failed. Please refresh and try again.');
          return;
        }
        
        const data = await response.json();
        
        if (!data.exists) {
          showError('Invalid code. No sender found with this code.');
          return;
        }
        
        // Room exists, connect
        await connectAsReceiver(code);
      } catch (err) {
        console.error('Room validation error:', err);
        showError('Could not validate code. Please try again.');
      }
    });

    passphraseInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        getFileBtn.click();
      }
    });

    // WebSocket & WebRTC
    async function connectAsSender() {
      // Get Turnstile token for WebSocket connection
      let token;
      try {
        token = await getTurnstileToken();
      } catch (e) {
        showSenderError('Security verification failed. Please refresh and try again.');
        resetState();
        return;
      }

      // Store reference to THIS websocket to detect stale handlers
      const currentWs = new WebSocket(getWebSocketUrl(passphrase, token));
      ws = currentWs;

      currentWs.onopen = () => {
        if (ws !== currentWs) return; // Stale connection
        console.log('Sender connected to signaling server');
        waitingState.classList.remove('hidden');
        startCodeExpiryTimer();
      };

      currentWs.onmessage = (event) => {
        if (ws !== currentWs) return; // Stale connection
        const message = JSON.parse(event.data);
        
        // Handle peer disconnection
        if (message.type === 'peer-disconnected') {
          showSenderError('Receiver disconnected.');
          return;
        }
        
        // Check if this is a "ready" notification from receiver
        if (message.type === 'ready') {
          console.log('Receiver is ready, creating peer connection');
          
          if (!peer) {
            // Create peer as initiator - this will generate an offer
            peer = new SimplePeer({ initiator: true, trickle: false });
            
            peer.on('signal', (data) => {
              console.log('Sender sending signal:', data.type);
              if (currentWs.readyState === WebSocket.OPEN) {
                currentWs.send(JSON.stringify(data));
              }
            });

            peer.on('connect', () => {
              console.log('P2P connected');
              stopCodeExpiryTimer();
              currentWs.close();
              startSending();
            });

            peer.on('error', (err) => {
              console.error('Peer error:', err);
            });

            peer.on('close', () => {
              // Peer connection closed
            });
          }
          return;
        }

        // This is a SimplePeer signal (answer from receiver)
        if (peer && (message.type === 'answer' || message.sdp || message.candidate)) {
          console.log('Sender received signal:', message.type);
          peer.signal(message);
        }
      };

      currentWs.onerror = () => {
        if (ws !== currentWs) return; // Stale connection
        console.error('WebSocket error');
        showSenderError('Connection failed. Please try again.');
      };

      currentWs.onclose = () => {
        console.log('WebSocket closed');
        // Only show error if this is still the active connection and peer isn't connected
        if (ws === currentWs && (!peer || !peer.connected)) {
          showSenderError('Connection lost. Please try again.');
        }
      };
    }

    async function connectAsReceiver(code) {
      // Get Turnstile token for WebSocket connection
      let token;
      try {
        token = await getTurnstileToken();
      } catch (e) {
        showError('Security verification failed. Please refresh and try again.');
        resetState();
        return;
      }

      // Store reference to THIS websocket to detect stale handlers
      const currentWs = new WebSocket(getWebSocketUrl(code, token));
      ws = currentWs;

      currentWs.onopen = () => {
        if (ws !== currentWs) return; // Stale connection
        console.log('Receiver connected to signaling server');
        
        // Room already validated via API, create peer immediately
        peer = new SimplePeer({ initiator: false, trickle: false });

        peer.on('signal', (data) => {
          console.log('Receiver sending signal:', data.type);
          if (currentWs.readyState === WebSocket.OPEN) {
            currentWs.send(JSON.stringify(data));
          }
        });

        peer.on('connect', () => {
          console.log('P2P connected');
          currentWs.close();
        });

        peer.on('data', (data) => {
          // Wrap async handler to avoid blocking SimplePeer
          handleIncomingData(data).catch(e => console.error('Data handling error:', e));
        });

        peer.on('error', (err) => {
          console.error('Peer error:', err);
          showError('Connection failed. Please try again.');
        });

        peer.on('close', () => {
          // Peer connection closed
        });

        // Send ready signal to trigger sender's offer
        currentWs.send(JSON.stringify({ type: 'ready' }));
      };

      currentWs.onmessage = (event) => {
        if (ws !== currentWs) return; // Stale connection
        const message = JSON.parse(event.data);
        
        // Handle peer disconnection
        if (message.type === 'peer-disconnected') {
          showError('Sender disconnected. The transfer was cancelled.');
          return;
        }
        
        // Only process SimplePeer signals (offer from sender)
        if (peer && (message.type === 'offer' || message.sdp || message.candidate)) {
          console.log('Receiver received signal:', message.type);
          peer.signal(message);
        }
      };

      currentWs.onerror = () => {
        if (ws !== currentWs) return; // Stale connection
        showError('Could not connect. Check the code and try again.');
      };

      currentWs.onclose = () => {
        console.log('WebSocket closed');
        // Only show error if this is still the active connection and peer isn't connected
        if (ws === currentWs && (!peer || !peer.connected)) {
          showError('Connection lost. Please try again.');
        }
      };
    }

    function showError(message) {
      errorText.textContent = message;
      errorMessage.classList.remove('hidden');
      setButtonLoading(false);
    }

    function showSenderError(message) {
      senderErrorText.textContent = message;
      senderErrorMessage.classList.remove('hidden');
      waitingState.classList.add('hidden');
      stopCodeExpiryTimer();
    }

    function startCodeExpiryTimer() {
      codeExpirySeconds = 600; // 10 minutes
      updateCodeExpiryDisplay();
      
      codeExpiryInterval = setInterval(() => {
        codeExpirySeconds--;
        updateCodeExpiryDisplay();
        
        if (codeExpirySeconds <= 0) {
          stopCodeExpiryTimer();
          showSenderError('Code expired. Please select your file again.');
        }
      }, 1000);
    }

    function stopCodeExpiryTimer() {
      if (codeExpiryInterval) {
        clearInterval(codeExpiryInterval);
        codeExpiryInterval = null;
      }
    }

    function updateCodeExpiryDisplay() {
      const mins = Math.floor(codeExpirySeconds / 60);
      const secs = codeExpirySeconds % 60;
      codeExpiryTime.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // File transfer
    let transferStartTime = 0;
    let bytesTransferred = 0;
    let incomingFileInfo = null;
    let fileStream = null;
    let writer = null;
    let writeQueue = Promise.resolve();

    function startSending() {
      isTransferring = true;
      transferStartTime = Date.now();
      bytesTransferred = 0;

      // Show transfer overlay
      transferOverlay.classList.remove('hidden');
      transferProgress.classList.remove('hidden');
      transferComplete.classList.add('hidden');
      transferStatus.textContent = 'Sending';
      transferFilename.textContent = selectedFile.name;

      // Send file info first (with magic prefix)
      const fileInfo = {
        type: 'file-info',
        name: selectedFile.name,
        size: selectedFile.size
      };
      peer.send(CTRL_PREFIX + JSON.stringify(fileInfo));

      // Start sending chunks
      sendFileChunks();
    }

    async function sendFileChunks() {
      const reader = selectedFile.stream().getReader();
      let sentBytes = 0;

      const sendChunk = async () => {
        try {
          const { done, value } = await reader.read();
          
          if (done) {
            peer.send(CTRL_PREFIX + JSON.stringify({ type: 'file-complete' }));
            showTransferComplete('File sent successfully');
            return;
          }

          // Send in 64KB chunks
          let offset = 0;
          while (offset < value.length) {
            const chunk = value.slice(offset, offset + CHUNK_SIZE);
            
            // Wait for buffer to drain if needed (backpressure)
            while (peer._channel && peer._channel.bufferedAmount > CHUNK_SIZE * 4) {
              await new Promise(resolve => setTimeout(resolve, 10));
            }

            peer.send(chunk);
            offset += chunk.length;
            sentBytes += chunk.length;
            bytesTransferred = sentBytes;

            updateProgress(sentBytes, selectedFile.size);
          }

          // Continue with next chunk
          sendChunk();
        } catch (error) {
          console.error('Send error:', error);
        }
      };

      sendChunk();
    }

    async function handleIncomingData(data) {
      try {
        const constructorName = data?.constructor?.name || 'unknown';
        
        // Convert Blob to ArrayBuffer if needed (some browsers send as Blob)
        if (data instanceof Blob || constructorName === 'Blob') {
          data = await data.arrayBuffer();
        }
        
        // String messages are control messages (JSON)
        if (typeof data === 'string') {
          try {
            const message = JSON.parse(data);
            handleControlMessage(message);
          } catch (e) {
            console.error('Invalid JSON message:', e);
          }
          return;
        }

        // Convert to Uint8Array for consistent handling
        let bytes;
        if (data instanceof Uint8Array) {
          bytes = data;
        } else if (data instanceof ArrayBuffer || constructorName === 'ArrayBuffer') {
          bytes = new Uint8Array(data);
        } else if (data.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        } else if (ArrayBuffer.isView(data)) {
          bytes = new Uint8Array(data.buffer);
        } else {
          bytes = new Uint8Array(data);
        }
        
        // Check if this is a control message (starts with magic prefix \x00KALSU\x00)
        const prefixBytes = [0, 75, 65, 76, 83, 85, 0];
        const hasPrefix = bytes.length > 7 && prefixBytes.every((b, i) => bytes[i] === b);
        
        if (hasPrefix) {
          try {
            const text = new TextDecoder().decode(bytes.slice(7));
            const message = JSON.parse(text);
            handleControlMessage(message);
            return;
          } catch (e) {
            console.error('Failed to parse control message:', e);
          }
        }
        
        // Binary data - file chunk
        if (writer && incomingFileInfo) {
          bytesTransferred += bytes.length;
          updateProgress(bytesTransferred, incomingFileInfo.size);
          
          writeQueue = writeQueue.then(() => writer.write(bytes)).catch(e => {
            console.error('Write error:', e);
          });
          return;
        }

        // Binary data but no writer yet - try to decode as control message
        try {
          const text = new TextDecoder().decode(bytes);
          const message = JSON.parse(text);
          handleControlMessage(message);
        } catch (e) {
          console.error('Unexpected data before file-info');
        }
      } catch (error) {
        console.error('Data handling error:', error);
      }
    }

    function handleControlMessage(message) {
      // Handle peer disconnection during transfer
      if (message.type === 'peer-disconnected') {
        if (writer) {
          try { writer.abort(); } catch (e) {}
        }
        transferOverlay.classList.add('hidden');
        showError('The other device disconnected. Transfer cancelled.');
        return;
      }
      
      if (message.type === 'file-info') {
        incomingFileInfo = message;
        isTransferring = true;
        transferStartTime = Date.now();
        bytesTransferred = 0;
        writeQueue = Promise.resolve();

        // Show transfer overlay
        transferOverlay.classList.remove('hidden');
        transferProgress.classList.remove('hidden');
        transferComplete.classList.add('hidden');
        transferStatus.textContent = 'Receiving';
        transferFilename.textContent = message.name;

        // Setup StreamSaver
        fileStream = streamSaver.createWriteStream(message.name, {
          size: message.size
        });
        writer = fileStream.getWriter();
        return;
      }

      if (message.type === 'file-complete') {
        // Wait for all pending writes to complete before closing
        writeQueue.then(() => {
          return writer.close();
        }).then(() => {
          showTransferComplete('File saved successfully');
        }).catch(e => {
          console.error('Close error:', e);
          showTransferComplete('File saved');
        });
        return;
      }
    }

    function updateProgress(current, total) {
      const percent = Math.round((current / total) * 100);
      const elapsed = (Date.now() - transferStartTime) / 1000;
      const speed = current / elapsed;
      const remaining = (total - current) / speed;

      progressBar.style.width = `${percent}%`;
      transferPercent.textContent = `${percent}%`;
      transferSpeed.textContent = `${formatBytes(speed)}/s`;
      transferEta.textContent = formatTime(remaining);
    }

    function showTransferComplete(message) {
      isTransferring = false;
      transferProgress.classList.add('hidden');
      transferComplete.classList.remove('hidden');
      transferCompleteHint.textContent = message;
      
      // Update security message based on sender/receiver
      if (currentMode === 'send') {
        transferSecurityText.textContent = 'No copy was stored on any server';
      } else {
        transferSecurityText.textContent = 'Transfer was private and direct';
      }
    }

    closeTransferBtn.addEventListener('click', () => {
      resetState();
    });

    // Prevent accidental navigation during transfer
    window.addEventListener('beforeunload', (e) => {
      if (isTransferring) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>
</body>
</html>

